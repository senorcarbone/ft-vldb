%!TEX root = main.tex


\section{Implementation and Usage}
\label{sec:implementation}

\paris{I am dumping most of my thoughts in this section without polishing anything yet since I first need someone who knows it more to point out important things that I might be missing.}

\subsection{State Backend Support}

Managed state consistency is coordinated by Flink's snapshotting algorithm (\autoref{sec:snapshots}), however, state access and persistence are the main concerns of the state backend module. There are currently three different backends supported by the Flink stack : 1) \emph{In-Memory}, 2) \emph{File-Based} and 3) \emph{Out-of-Core}. Depending on the overall expected managed state accumulated in a pipeline, each of the backends offers a suitable trade-off between execution throughput, scalability and flexibility.

\para{In-Memory}
The \emph{In-Memory} backend maintains active managed state in local, allocated heap space and snapshotted state within the Job Manager's heap space. This is, in some distinct use-cases, a preferable choice that yields very high throughput. For example, pipeline testing and debugging or actual deployments with low state capacity requirements such as filtering and basic ETL can make a reasonable use of this backend. Upon each task's \texttt{triggerSnapshot()} invocation local state is serialized, copied and transfered to the Job Manager together with typical snapshot metadata. As a result, the Job Manager needs to have enough heap space allocated in order to be able sustain all physical task materialized states for each snapshot.

\para{File-Based:}
In most cases, complete pipeline snapshots involve much larger active managed state than what can fit in memory of a single node. The \emph{File-Based} backend leaves distributed uncommitted state in heap space, however, whenever snapshotting is invoked the state is being copied from heap to a configured distributed file system directory (e.g., HDFS). As a result, snapshot metadata is also kept to a minimum (containing mainly file references), while throughput can remain high since operations on uncommitted memory happen in-place at the local heap.

\para{Out-of-Core:}
Complex pipelines often need to maintain very large managed state such as Terabytes of indexes and large sequences of sliding windows upon which user-defined logic can operate continuously. In such cases, local heap space is insufficient to maintain even locally accessed active state, especially for certain task operators (e.g., Flink's \texttt{WindowOperator}). Flink provides an \emph{out-of-core} backend that decouples state operations performed on each task from the physical location where state itself is persisted and updated. In its current implementation, out-of-core state is interfaced with an embedded file-backed key-value database (i.e., RocksDB). Therefore, state capacity is only limited by the file system space allocated at the host where this backend is deployed. Moreover, operations triggered on managed state such as \texttt{update} for mutable state and \texttt{add} for append-only \texttt{ListState} are carried over to the embedded key-value store instead. One of the benefits that are enabled out-of-the-box with such a scheme is that most per-key operations can be executed asynchronously at the backend without sacrificing throughput. On the other hand, state value retrievals can take more time to complete, especially if some specific state has to be retrieved from compacted files on disk and it is no longer within the backend's memory. \paris{@stefan please add or correct whatever you see fit. You know this part better than anyone else.}

\subsection{Asynchronous Snapshots and Notifications}
One of the advantages of the pipelined snapshotting protocol presented in \autoref{sec:snapshots} is that it does not restrain the actual acquisition of snapshots to be synchronous. A call of \texttt{triggerSnapshot()} by each task is expected to create an identical copy of the current state of that task. In case there is support by a backend module to execute this operation asynchronously, it can be used without violating consistency. The \emph{out-of-core} backend of Flink offers the capability to trigger snapshots in a purely asynchronous way by copying the full compacted key-value database to a backup directory by another thread, thus, letting normal processing proceed without interruptions. Once local snapshotting operations have been completed the notifications are triggered back at the tasks and carried out to the \emph{JobManager} alongside associated meta-data where a full snapshot can be declared as complete. 

Another feature that is provided to tasks as an optional asynchronous subscription-based mechanism is to trigger notifications about completed snapshots back at the tasks that request them. This is especially useful for garbage collection, discarding write ahead logs or for executing output commit protocols as we explain further in \autoref{sec:outputcommit}.

\subsection{Queryable State}
\paris{We can briefly mention how queryable state is implemented for accessing uncommitted active state from outside the system.}

\subsection{Output Commit}
\label{sec:outputcommit}
\paris{explain idempotency and the rolling sink, truncate etc.}

\subsection{Asynchronous IO}
\paris{Maybe we can simply highlight how this operates and aligns with the snapshotting protocol}

\subsection{High Availability \& Reconfiguration}
\paris{This is just an implementation specific problem. We should mention how we utilized zookeeper and offer some insights about what metadata we store since it is useful for many people actually.}

	